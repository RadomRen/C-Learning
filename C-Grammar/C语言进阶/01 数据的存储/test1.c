#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

////以下代码Debug版本会死循环，Release不会死循环
//int main()
//{
//	int i = 0;
//	int arr[] = { 1,2,3,4,5,6,7,8,9,10,11 };
//	for (i = 0; i <= 12; i++)
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	}
//	return 0;
//}

////整型在内存中的存储
//int main()
//{
//	int a = -10;
//	return 0;
//}

//int main()
//{
//	char a = -129;
//	signed char b = -129;
//	unsigned char c = -129;
//	printf("a = %d, b = %d, c = %d", a, b, c);
//	return 0;
//
//	//-1
//	//10000000000000000000000000000001 - 原码
//	//11111111111111111111111111111110 - 反码
//	//11111111111111111111111111111111 - 补码
//	//11111111
//	// a:
//	//11111111111111111111111111111111 - 补码
//	//11111111111111111111111111111110 - 反码
//	//10000000000000000000000000000001 - 原码
//	//a = -1
//	// b:
//	//11111111111111111111111111111111 - 补码
//	//11111111111111111111111111111110 - 反码
//	//10000000000000000000000000000001 - 原码
//	//b = -1
//	//c:
//	//00000000000000000000000011111111 - 原码、反码、补码相同
//	//c = 255
//
//	//-255
//	//10000000000000000000000011111111 - 原码
//	//11111111111111111111111100000000 - 反码
//	//11111111111111111111111100000001 - 补码
//	//00000001
//	//a:
//	//00000000000000000000000000000001
//	//a = 1
//	//b:
//	//00000000000000000000000000000001
//	//b = 1
//	//c:
//	//00000000000000000000000000000001
//	//c = 1
//
//	//-128
//	//10000000000000000000000010000000 - 原码
//	//11111111111111111111111101111111 - 反码
//	//11111111111111111111111110000000 - 补码
//	//10000000
//	//a:
//	//11111111111111111111111110000000 - 补码 与-128的补码相同，所以结果也是-128
//	//b:
//	//11111111111111111111111110000000 - 补码 与-128的补码相同，所以结果也是-128
//	//c:
//	//00000000000000000000000010000000 - 补码，反码，原码相同，结果为128
//
//	//-127
//	//10000000000000000000000001111111 - 原码
//	//11111111111111111111111110000000 - 反码
//	//11111111111111111111111110000001 - 补码
//	//10000001
//	//a:
//	//11111111111111111111111110000001 - 补码 与-127的补码相同，所以结果也是-127
//	//b:
//	//11111111111111111111111110000001 - 补码 与-127的补码相同，所以结果也是-127
//	//c:
//	//00000000000000000000000010000001 - 补码，原码相同，所以结果为129
//
//	//-129
//	//10000000000000000000000010000001 - 原码
//	//11111111111111111111111101111110 - 反码
//	//11111111111111111111111101111111 - 补码
//	//01111111
//	//a:
//	//00000000000000000000000001111111 - 补码，原码相同，结果为127
//	//b:
//	//00000000000000000000000001111111 - 补码，原码相同，结果为127
//	//c:
//	//00000000000000000000000001111111 - 补码，原码相同，结果为127
//}

//int main()
//{
//	char a = -128;
//	//-128
//	//10000000000000000000000010000000 - 原码
//	//11111111111111111111111101111111 - 反码
//	//11111111111111111111111110000000 - 补码
//	//截断 10000000
//	//整型提升
//	//11111111111111111111111110000000 - 对于unsigned来说，没有符号位，原反补相同
//	//最后结果为0xfffffff80无符号表示
//	printf("%u", a);
//	return 0;
//}

//int main()
//{
//	char a = 128;
//	//128
//	//00000000000000000000000010000000
//	//截断 10000000
//	//整型提升
//	//11111111111111111111111110000000
//	//结果与上面相同
//	printf("%u", a);
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	//-20
//	//10000000000000000000000000010100 - 原码
//	//11111111111111111111111111101011 - 反码
//	//11111111111111111111111111101100 - 补码
//	unsigned int j = 10;
//	//10
//	//00000000000000000000000000001010 - 原反补相同
//	//-20 + 10
//	//11111111111111111111111111101100
//	// +
//	//00000000000000000000000000001010
//	// =
//	//11111111111111111111111111110110 - 补码
//	//11111111111111111111111111110011 - 反码
//	//10000000000000000000000000001100 - 原码
//	// = -10
//	printf("%d\n", i + j);
//}

//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		//当i == 0 时执行 i--得到：
//		// i = i - 1
//		// 0
//		//00000000000000000000000000000000
//		// -
//		// 1
//		//00000000000000000000000000000001
//		// =
//		//11111111111111111111111111111111 - 补码 存到无符号整形 i 中，即原反补相同
//		//所以得到 i = 2^32 - 1, 该值大于 0，所以继续执行 i--，陷入死循环
//		//
//		printf("%u\n", i);
//	}
//}

//int main()
//{
//	char a[1000];
//	int i = 0;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	a[1000] = { -1, -2, -3,..., -127, -128, 127, 126, ..., 3, 2, 1, 0, -1, -2, -3......}
//	要了解有符号类型数据内部容纳的每个数的分布规则
//	printf("%d", strlen(a));//255
//	return 0;
//}


//unsigned char i = 0;
//int main()
//{
//	//死循环，unsigned char 的范围本来就是0~255，条件恒成立
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}

#include <float.h>
#include <limits.h>

//int main()
//{
//    //以整型的视角（方式）向内存存储数据
//    int n = 9;
//    //将pFloat定义为浮点型的指针，指向n的地址
//    //同时也决定了，通过该指针访问该地址数据的视角（方式）
//    float* pFloat = (float*)&n;
//    //以整型视角（方式）取出数据，没有异常
//    printf("n = %d\n", n);//9
//             //将用整型方式存储的数据，使用浮点型方式读出，就出现了问题
//             //这是因为整型和浮点型定义的向内存存取数据的方式是不同的
//    printf("*pFloat = %f\n", *pFloat);//0.000000
//             //以浮点数的方式向同一地址存放数据9.0
//
//    *pFloat = 9.0;
//    //以整型的方式读该块内存的数据，出现异常情况
//    //注意：此时该块内存的数据是用浮点型的方式来存的
//    printf("n = %d\n", n);//1091567616
//             //使用浮点型的方式读取数据没有问题
//    printf("*pFloat = %f\n", *pFloat);//9.000000
//    return 0;
//}

//int main()
//{
//	float f = 5.5;
//	//101.1
//	//s = 0    M = 1.011    E = 2
//	//s = 0    M =   011    E = 2 + 127
//	//0 10000001 01100000000000000000000
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	//0x40B00000
//	return 0;
//}


////通过之前的理论再次解读这个例子
//int main()
//{
//	//将数据以int的方式存入内存空间
//	int n = 9;
//	//9
//	//00000000000000000000000000001001
//	//0x00000009
//	float* pFloat = (float*)&n;
//
//	//按照int类型正常读取
//	printf("n = %d\n", n);//9
//
//	//按照float模式读取
//	//00000000000000000000000000001001
//	//0 00000000 00000000000000000001001
//	//s = 0，为正，E为全0，M = 1.00000000000000000001001
//	//根据当E为全0时的规则，E = 1 - 127, M = 0.00000000000000000001001
//	//那么此时*pFloat的值就是 0.00000000000000000001001 * 2^(-126)
//	//所以显示为0.000000
//	printf("*pFloat = %f\n", *pFloat);//0.000000
//
//	//将数据用float的方式存入内存
//	*pFloat = 9.0;
//	//9.0 -> 1001.0 -> 1.0010 * 2^3
//	//s = 0   M = 001   E = 3 + 127
//	//0 10000010 00100000000000000000000
//	
//	//按照int方式读取
//	//0100 0001 0001 0000 0000 0000 0000 0000
//	//0x41100000 = 1091567616
//	printf("n = %d\n", n);//1091567616
//
//	//正常按照float的方式读取
//	printf("*pFloat = %f\n", *pFloat);//9.000000
//	return 0;
//}

